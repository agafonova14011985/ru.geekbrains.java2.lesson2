package Lesson3.Collections;

import java.util.*;
import java.util.function.Predicate;

public class Collections {


    public static void main(String[] args) {

        //cоздан список строк list , хранить в этом списке можно лишь строки
        //если <String> не указано то это Обьекты (числа строки коты.....)
        //нужно указать обязательно тип данных для работы с коллекцией/
        //изменяемый размар массива
        // обертка над обычным джававским массивом/есть массив объектов/
        List<String> list =  new ArrayList<>();

        //это из 1 из джавы такой же как и ArrayList<>();
        // но все методы которые публичные они синхронизированны,
        // потокобезопасный метод, медленный и тяжелый , молоиспользуется
        List<String> list1 = new Vector<>();

        //связанный список, элементы знают о предыдущем и предшевствующем
        //расширенная очередь, нет массивов, тоео есть ссылки на 2 объекта
        //он знает 1 - сколько у него элементов
        //2 -ссылку на 1 элемент  игде последний элемент
        //проще ArrayList<>(); но со своими нюансами, долго искать элемент из середины
        List<String> list2 = new LinkedList<>();

        //добавление элементов в список
        list.add("A");
        list.add("B");
        list.add("C");
        list.add("C");
        //list.add(null); так же печатаются но лучше их не использовать

        //перегруженный метод add, ожидает, в нужное место записывает новый элемент + сдвиг
        list.add(3,"подстановка на нужное место W");

        //поменять или достать элемент которого нет нельзя выдаст  исключение,
        //выходить за пределы списка нельзя
        list.set(4,"Замена  ");

        //добавление целой коллекции
        list.addAll(Arrays.asList("Новая коллекция", "A", "A", "A"));

        //удаление по индексу
        list.remove(0);

        //удаление по элементу, удалиться первый по списку, дубликат остается
        list.remove("A");

        //удаление вех вариантов ввсех совпадений
        //list.removeAll(List.of("A"));

        //удаление элементов по логике
        //list.removeIf( s -> false);

        //удаление элементов по характеристике, например длина слов длиннее 3
        list.removeIf( s -> s.length() > 5);

        //удалить все элементы
        //list.clear();

        //щпределение количества элементов с списке
        list.size();
        System.out.println(list.size());

        //сортировка с компаратором этот по адфавиту
        list.sort(String::compareToIgnoreCase);
        
        //сохранение всех переданных элементов все остальные будут снесены
       // list.retainAll(java.util.Collections.singleton(4));
        
        // ожидает унарный оператор заменяет элементы при помощи логики в нашем случае добавит vvv
        // к каждому элементу (это s -> s + "vvv" лямбда)
        list.replaceAll(s -> s + "vvv");

        //сортировка и определение какой больше какой  меньше
        //тоже самое что и list.sort(String::compareToIgnoreCase);
        list.sort((e1, e2) -> e1.compareToIgnoreCase(e2));

        //

        System.out.println(list);

        //работа со всем списком / обойти циклом / методом get  по индексу
       /* for (int i = 0; i < list.size(); i++){
            System.out.println(list.get(i));
        }
        */
        //или так тоже самое/
        for (String s : list) {
            System.out.println(s);
        }

        //или так итератор, обходит коллЕкцию, достать элемент без индексов/вставить /снести/
        Iterator<String> iterator = list.iterator();
        System.out.println(iterator.next());
        //или
        //iterator.remove();

        //работает со списками, дабовлять менять проверять предыдущий индекс,
        // возвращает значение индексов
       /* while (iterator.hasNext()){
            System.out.println(iterator.next());
            iterator.remove();
            iterator.hashCode();
        }*/

        //интерффейс прописывающий действие , которое будет произведенно с каждым элементом
        //все элементы
        list.forEach(System.out::println);




    }
}
